#!/usr/bin/env python
import h5py
import numpy
import sys, os, logging, argparse
import pycbc.workflow as wf
import pycbc
from pycbc.conversions import mchirp_from_mass1_mass2
from pycbc.waveform.spa_tmplt import spa_length_in_time
from scipy.optimize import minimize_scalar
from multiprocessing import Pool
import configparser
import pycbc.psd
from copy import copy

def get_flow(time, m1, m2):
    def dt(flow):
        t = spa_length_in_time(mass1=m1, mass2=m2, f_lower=flow, phase_order=-1) 
        return abs(t - time)
    res = minimize_scalar(dt, [1, 60])
    return res['x']

# loop over number of loudest events to be analyzed
def precalc(num_event):

    time = tc[num_event]
    m1 = m1s[num_event]
    m2 = m2s[num_event]
    mchirp = mchirps[num_event]
    cov = cv[num_event]
    ifos = []
    for ifo in opts.instruments:
        ifos.append(ifo)
    instr = ' '.join(ifos)

    from pycbc.detector import Detector
    from pycbc.waveform import get_fd_waveform
    from pycbc.filter import sigma
    from pycbc import cosmology

    hp, hc = get_fd_waveform(approximant="lgw", 
                            mass1=m1, mass2=m2, inclination=inc[num_event],
                            f_lower=1.0, delta_f=df, distance=dist[num_event],
                            source_ra=ra[num_event], source_dec=dec[num_event], 
                            lens_ra=ra[num_event], lens_dec=dec[num_event]+.2, # check the significance of anywhere in that circular region
                            zs=cosmology.redshift_from_comoving_volume(cv[num_event]), 
                            zl=0.5, mL=1e8, lens_model_list=['POINT_MASS'], optim=optim
)

# evaluate time delays 
